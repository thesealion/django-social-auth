"""
Google OpenID and OAuth support

OAuth works straightforward using anonymous configurations, username
is generated by requesting email to the not documented, googleapis.com
service. Registered applications can define settings GOOGLE_CONSUMER_KEY
and GOOGLE_CONSUMER_SECRET and they will be used in the auth process.
Setting GOOGLE_OAUTH_EXTRA_SCOPE can be used to access different user
related data, like calendar, contacts, docs, etc.

OAuth2 works similar to OAuth but application must be defined on Google
APIs console https://code.google.com/apis/console/ Identity option.

OpenID also works straightforward, it doesn't need further configurations.
"""
import logging
logger = logging.getLogger(__name__)

from urllib import urlencode
from urllib2 import Request, urlopen

from django.conf import settings
from django.utils import simplejson

from social_auth.backends import OpenIdAuth, ConsumerBasedOAuth, BaseOAuth2, \
                                 OAuthBackend, OpenIDBackend, USERNAME


# Google OAuth base configuration
GOOGLE_OAUTH_SERVER = 'www.google.com'
GOOGLE_OAUTH_AUTHORIZATION_URL = 'https://www.google.com/accounts/OAuthAuthorizeToken'
GOOGLE_OAUTH_REQUEST_TOKEN_URL = 'https://www.google.com/accounts/OAuthGetRequestToken'
GOOGLE_OAUTH_ACCESS_TOKEN_URL = 'https://www.google.com/accounts/OAuthGetAccessToken'

# Google OAuth2 base configuration
GOOGLE_OAUTH2_SERVER = 'accounts.google.com'
GOOGLE_OATUH2_AUTHORIZATION_URL = 'https://accounts.google.com/o/oauth2/auth'

# scope for user email, specify extra scopes in settings, for example:
# GOOGLE_OAUTH_EXTRA_SCOPE = ['https://www.google.com/m8/feeds/']
GOOGLE_OAUTH_SCOPE = ['https://www.googleapis.com/auth/userinfo#email']
GOOGLEAPIS_EMAIL = 'https://www.googleapis.com/userinfo/email'
GOOGLE_OPENID_URL = 'https://www.google.com/accounts/o8/id'

EXPIRES_NAME = getattr(settings, 'SOCIAL_AUTH_EXPIRATION', 'expires')


# Backends
class GoogleOAuthBackend(OAuthBackend):
    """Google OAuth authentication backend"""
    name = 'google-oauth'

    def get_user_id(self, details, response):
        "Use google email as unique id"""
        return details['email']

    def get_user_details(self, response):
        """Return user details from Orkut account"""
        email = response['email']
        return {USERNAME: email.split('@', 1)[0],
                'email': email,
                'fullname': '',
                'first_name': '',
                'last_name': ''}


from social_auth.backends import *
from social_auth.models import UserSocialAuth
import base64
import json
class GoogleOAuth2Backend(GoogleOAuthBackend):
    """Google OAuth2 authentication backend"""
    name = 'google-oauth2'
    EXTRA_DATA = [('refresh_token', 'refresh_token'),
                  ('expires_in', EXPIRES_NAME)]

    def authenticate(self, *args, **kwargs):
        """Authenticate user using social credentials

        Authentication is made if this is the correct backend, backend
        verification is made by kwargs inspection for current backend
        name presence.
        """
        # Validate backend and arguments. Require that the Social Auth
        # response be passed in as a keyword argument, to make sure we
        # don't match the username/password calling conventions of
        # authenticate.
        if not (self.name and kwargs.get(self.name) and 'response' in kwargs):
            return None

        response = kwargs.get('response')
        details = self.get_user_details(response)
        uid = self.get_user_id(details, response)
        is_new = False
        user = kwargs.get('user')

        try:
            social_user = self.get_social_auth_user(uid)
        except UserSocialAuth.DoesNotExist:
            if user is None:  # new user
                if not CREATE_USERS or not kwargs.get('create_user', True):
                    # Send signal for cases where tracking failed registering
                    # is useful.
                    socialauth_not_registered.send(sender=self.__class__,
                                                   uid=uid,
                                                   response=response,
                                                   details=details)
                    return None

                fail = True
                try:
                    s = response.get('id_token').split('.')[1]
                    openid_id = json.loads(base64.urlsafe_b64decode(s + '=' * (4 - len(s) % 4)))['openid_id']
                except Exception:
                    pass
                else:
                    try:
                        social_user = UserSocialAuth.objects.select_related('user').get(provider='openid', uid=openid_id)
                    except UserSocialAuth.DoesNotExist:
                        pass
                    else:
                        user = social_user.user
                if not user:
                    email = details.get('email')
                    if email and ASSOCIATE_BY_MAIL:
                        # try to associate accounts registered with the same email
                        # address, only if it's a single object. ValueError is
                        # raised if multiple objects are returned
                        try:
                            user = User.objects.get(email=email)
                        except MultipleObjectsReturned:
                            raise ValueError('Not unique email address supplied')
                        except User.DoesNotExist:
                            user = None
                    if not user:
                        username = self.username(details)
                        logger.debug('Creating new user with username %s and email %s',
                                     username, sanitize_log_data(email))
                        user = User.objects.create_user(username=username,
                                                        email=email)
                        is_new = True

            try:
                social_user = self.associate_auth(user, uid, response, details)
            except IntegrityError:
                # Protect for possible race condition, those bastard with FTL
                # clicking capabilities
                social_user = self.get_social_auth_user(uid)

        # Raise ValueError if this account was registered by another user.
        if user and user != social_user.user:
            raise ValueError('Account already in use.', social_user)
        user = social_user.user

        # Flag user "new" status
        if NEW_USER_CHECKER(user):
            is_new = True
        setattr(user, 'is_new', is_new)

        # Update extra_data storage, unless disabled by setting
        if LOAD_EXTRA_DATA:
            extra_data = self.extra_data(user, uid, response, details)
            if extra_data and social_user.extra_data != extra_data:
                social_user.extra_data = extra_data
                social_user.save()

        user.social_user = social_user

        # Update user account data.
        self.update_user_details(user, response, details, is_new)
        return user


class GoogleBackend(OpenIDBackend):
    """Google OpenID authentication backend"""
    name = 'google'

    def get_user_id(self, details, response):
        """Return user unique id provided by service. For google user email
        is unique enought to flag a single user. Email comes from schema:
        http://axschema.org/contact/email"""
        return details['email']

# Auth classes
class GoogleAuth(OpenIdAuth):
    """Google OpenID authentication"""
    AUTH_BACKEND = GoogleBackend

    def openid_url(self):
        """Return Google OpenID service url"""
        return GOOGLE_OPENID_URL


class BaseGoogleOAuth(ConsumerBasedOAuth):
    """Base class for Google OAuth mechanism"""
    AUTHORIZATION_URL = GOOGLE_OAUTH_AUTHORIZATION_URL
    REQUEST_TOKEN_URL = GOOGLE_OAUTH_REQUEST_TOKEN_URL
    ACCESS_TOKEN_URL = GOOGLE_OAUTH_ACCESS_TOKEN_URL
    SERVER_URL = GOOGLE_OAUTH_SERVER

    def user_data(self, access_token):
        """Loads user data from G service"""
        raise NotImplementedError('Implement in subclass')


class GoogleOAuth(BaseGoogleOAuth):
    """Google OAuth authorization mechanism"""
    AUTH_BACKEND = GoogleOAuthBackend
    SETTINGS_KEY_NAME = 'GOOGLE_CONSUMER_KEY'
    SETTINGS_SECRET_NAME = 'GOOGLE_CONSUMER_SECRET'

    def user_data(self, access_token):
        """Return user data from Google API"""
        request = self.oauth_request(access_token, GOOGLEAPIS_EMAIL,
                                     {'alt': 'json'})
        url, params = request.to_url().split('?', 1)
        return googleapis_email(url, params)

    def oauth_request(self, token, url, extra_params=None):
        extra_params = extra_params or {}
        scope = GOOGLE_OAUTH_SCOPE + \
                getattr(settings, 'GOOGLE_OAUTH_EXTRA_SCOPE', [])
        extra_params.update({
            'scope': ' '.join(scope),
            'xoauth_displayname': getattr(settings, 'GOOGLE_DISPLAY_NAME',
                                          'Social Auth')
        })
        return super(GoogleOAuth, self).oauth_request(token, url, extra_params)

    def get_key_and_secret(self):
        """Return Google OAuth Consumer Key and Consumer Secret pair, uses
        anonymous by default, beware that this marks the application as not
        registered and a security badge is displayed on authorization page.
        http://code.google.com/apis/accounts/docs/OAuth_ref.html#SigningOAuth
        """
        try:
            return super(GoogleOAuth, self).get_key_and_secret()
        except AttributeError:
            return 'anonymous', 'anonymous'

    @classmethod
    def enabled(cls):
        """Google OAuth is always enabled because of anonymous access"""
        return True


# TODO: Remove this setting name check, keep for backward compatibility
_OAUTH2_KEY_NAME = hasattr(settings, 'GOOGLE_OAUTH2_CLIENT_ID') and \
                   'GOOGLE_OAUTH2_CLIENT_ID' or \
                   'GOOGLE_OAUTH2_CLIENT_KEY'


class GoogleOAuth2(BaseOAuth2):
    """Google OAuth2 support"""
    AUTH_BACKEND = GoogleOAuth2Backend
    AUTHORIZATION_URL = 'https://accounts.google.com/o/oauth2/auth'
    ACCESS_TOKEN_URL = 'https://accounts.google.com/o/oauth2/token'
    SETTINGS_KEY_NAME = _OAUTH2_KEY_NAME
    SETTINGS_SECRET_NAME = 'GOOGLE_OAUTH2_CLIENT_SECRET'

    def get_scope(self):
        return GOOGLE_OAUTH_SCOPE + \
               getattr(settings, 'GOOGLE_OAUTH_EXTRA_SCOPE', [])

    def user_data(self, access_token):
        """Return user data from Google API"""
        data = {'oauth_token': access_token, 'alt': 'json'}
        return googleapis_email(GOOGLEAPIS_EMAIL, urlencode(data))


def googleapis_email(url, params):
    """Loads user data from googleapis service, only email so far as it's
    described in http://sites.google.com/site/oauthgoog/Home/emaildisplayscope

    Parameters must be passed in queryset and Authorization header as described
    on Google OAuth documentation at:
        http://groups.google.com/group/oauth/browse_thread/thread/d15add9beb418ebc
    and:
        http://code.google.com/apis/accounts/docs/OAuth2.html#CallingAnAPI
    """
    request = Request(url + '?' + params, headers={'Authorization': params})
    try:
        return simplejson.loads(urlopen(request).read())['data']
    except (ValueError, KeyError, IOError):
        return None

class YandexOAuth2Backend(OAuthBackend):
    name = 'yandex-oauth2'

    def get_user_id(self, details, response):
        return details['id']

    def get_user_details(self, response):
        return {'email': response.get('default_email') or
                         response.get('emails', [''])[0],
                'id': response['id']}

    #EXTRA_DATA = [('refresh_token', 'refresh_token'),
    #              ('expires_in', EXPIRES_NAME)]

    def authenticate(self, *args, **kwargs):
        if not (self.name and kwargs.get(self.name) and 'response' in kwargs):
            return None

        response = kwargs.get('response')
        details = self.get_user_details(response)
        uid = self.get_user_id(details, response)
        is_new = False
        user = kwargs.get('user')

        try:
            social_user = self.get_social_auth_user(uid)
        except UserSocialAuth.DoesNotExist:
            if user is None:  # new user
                if not CREATE_USERS or not kwargs.get('create_user', True):
                    # Send signal for cases where tracking failed registering
                    # is useful.
                    socialauth_not_registered.send(sender=self.__class__,
                                                   uid=uid,
                                                   response=response,
                                                   details=details)
                    return None

                for openid_id in response.get('openid_identities', []):
                    try:
                        social_user = UserSocialAuth.objects.select_related('user').get(provider='openid', uid=openid_id)
                    except UserSocialAuth.DoesNotExist:
                        pass
                    else:
                        user = social_user.user
                        break
                if not user:
                    email = details.get('email')
                    if email and ASSOCIATE_BY_MAIL:
                        # try to associate accounts registered with the same email
                        # address, only if it's a single object. ValueError is
                        # raised if multiple objects are returned
                        try:
                            user = User.objects.get(email=email)
                        except MultipleObjectsReturned:
                            raise ValueError('Not unique email address supplied')
                        except User.DoesNotExist:
                            user = None
                    if not user:
                        username = self.username(details)
                        logger.debug('Creating new user with username %s and email %s',
                                     username, sanitize_log_data(email))
                        user = User.objects.create_user(username=username,
                                                        email=email)
                        is_new = True

            try:
                social_user = self.associate_auth(user, uid, response, details)
            except IntegrityError:
                # Protect for possible race condition, those bastard with FTL
                # clicking capabilities
                social_user = self.get_social_auth_user(uid)

        # Raise ValueError if this account was registered by another user.
        if user and user != social_user.user:
            raise ValueError('Account already in use.', social_user)
        user = social_user.user

        # Flag user "new" status
        if NEW_USER_CHECKER(user):
            is_new = True
        setattr(user, 'is_new', is_new)

        # Update extra_data storage, unless disabled by setting
        if LOAD_EXTRA_DATA:
            extra_data = self.extra_data(user, uid, response, details)
            if extra_data and social_user.extra_data != extra_data:
                social_user.extra_data = extra_data
                social_user.save()

        user.social_user = social_user

        # Update user account data.
        self.update_user_details(user, response, details, is_new)
        return user

class YandexOAuth2(BaseOAuth2):
    AUTH_BACKEND = YandexOAuth2Backend
    AUTHORIZATION_URL = 'https://oauth.yandex.com/authorize'
    ACCESS_TOKEN_URL = 'https://oauth.yandex.com/token'
    INFO_URL = 'https://login.yandex.ru/info'
    ACCESS_TOKEN_METHOD = 'POST'
    REDIRECT_STATE = False
    SETTINGS_KEY_NAME = 'YANDEX_OAUTH2_CLIENT_KEY'
    SETTINGS_SECRET_NAME = 'YANDEX_OAUTH2_CLIENT_SECRET'

    def get_user_details(self, response):
        raise Exception('remove?')
        return {'email': response.get('default_email') or
                         response.get('emails', [''])[0]}

    def user_data(self, access_token):
        params={'oauth_token': access_token, 'format': 'json', 'with_openid_identity': '1'}
        headers = {'Content-Type': 'application/x-www-form-urlencoded'}
        request = Request(self.INFO_URL, data=urlencode(params), headers=headers)

        try:
            response = simplejson.loads(urlopen(request).read())
        except (ValueError, KeyError):
            raise ValueError('Unknown OAuth2 response type')

        if response.get('error'):
            error = response.get('error_description') or response.get('error')
            raise ValueError('OAuth2 authentication failed: %s' % error)
        return response


# Backend definition
BACKENDS = {
    'google': GoogleAuth,
    'google-oauth': GoogleOAuth,
    'google-oauth2': GoogleOAuth2,
    'yandex-oauth2': YandexOAuth2,
}
